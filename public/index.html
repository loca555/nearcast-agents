<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>NearCast Agents</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'SF Mono', 'Cascadia Code', 'Fira Code', monospace;
      background: #0a0a0f;
      color: #e2e8f0;
      min-height: 100vh;
    }

    .header {
      padding: 20px 24px;
      border-bottom: 1px solid #1e293b;
      display: flex;
      align-items: center;
      gap: 12px;
    }
    .header h1 { font-size: 18px; font-weight: 600; color: #f8fafc; }
    .header .status { font-size: 12px; color: #64748b; }
    .header .dot { width: 8px; height: 8px; border-radius: 50%; display: inline-block; }
    .header .dot.online { background: #22c55e; box-shadow: 0 0 6px #22c55e; }
    .header .dot.offline { background: #64748b; }

    .container { padding: 20px 24px; max-width: 1400px; margin: 0 auto; }

    /* ── Карточки агентов ── */
    .agents-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 12px;
      margin-bottom: 24px;
    }
    .agent-card {
      background: #111827;
      border: 1px solid #1e293b;
      border-radius: 10px;
      padding: 16px;
      transition: border-color 0.2s;
    }
    .agent-card:hover { border-color: #334155; }
    .agent-card .top { display: flex; align-items: center; gap: 10px; margin-bottom: 12px; }
    .agent-card .avatar { font-size: 28px; }
    .agent-card .name { font-size: 15px; font-weight: 600; color: #f8fafc; }
    .agent-card .account { font-size: 10px; color: #475569; font-family: monospace; }
    .agent-card .pnl { font-size: 20px; font-weight: 700; margin-bottom: 8px; }
    .agent-card .pnl.positive { color: #22c55e; }
    .agent-card .pnl.negative { color: #ef4444; }
    .agent-card .pnl.zero { color: #64748b; }
    .agent-card .stats { font-size: 12px; color: #94a3b8; line-height: 1.6; }
    .agent-card .stats span { color: #e2e8f0; font-weight: 500; }
    .agent-card .last-active { font-size: 11px; color: #475569; margin-top: 8px; }

    /* ── Двухколоночный layout ── */
    .two-col {
      display: grid;
      grid-template-columns: 1fr 380px;
      gap: 16px;
    }
    @media (max-width: 900px) {
      .two-col { grid-template-columns: 1fr; }
    }

    /* ── Лента событий ── */
    .section-title {
      font-size: 14px;
      font-weight: 600;
      color: #94a3b8;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      margin-bottom: 12px;
    }
    .events-panel {
      background: #111827;
      border: 1px solid #1e293b;
      border-radius: 10px;
      padding: 16px;
      max-height: 600px;
      overflow-y: auto;
    }
    .event-row {
      display: flex;
      align-items: flex-start;
      gap: 10px;
      padding: 8px 0;
      border-bottom: 1px solid #1e293b22;
      font-size: 13px;
    }
    .event-row:last-child { border-bottom: none; }
    .event-avatar { font-size: 16px; flex-shrink: 0; width: 24px; text-align: center; }
    .event-badge {
      font-size: 10px;
      font-weight: 700;
      text-transform: uppercase;
      padding: 2px 6px;
      border-radius: 4px;
      flex-shrink: 0;
      min-width: 62px;
      text-align: center;
    }
    .event-badge.bet { background: #818cf822; color: #818cf8; }
    .event-badge.chat { background: #94a3b822; color: #94a3b8; }
    .event-badge.reply { background: #94a3b822; color: #94a3b8; }
    .event-badge.win { background: #22c55e22; color: #22c55e; }
    .event-badge.loss { background: #ef444422; color: #ef4444; }
    .event-badge.research { background: #f59e0b22; color: #f59e0b; }
    .event-badge.void { background: #64748b22; color: #64748b; }
    .event-badge.cycle { background: #06b6d422; color: #06b6d4; }
    .event-text { color: #cbd5e1; flex: 1; word-break: break-word; }
    .event-text .highlight { color: #f8fafc; font-weight: 500; }
    .event-time { font-size: 11px; color: #475569; flex-shrink: 0; white-space: nowrap; }

    /* ── Research панель ── */
    .research-panel {
      background: #111827;
      border: 1px solid #1e293b;
      border-radius: 10px;
      padding: 16px;
      max-height: 600px;
      overflow-y: auto;
    }
    .research-item {
      padding: 10px 0;
      border-bottom: 1px solid #1e293b22;
    }
    .research-item:last-child { border-bottom: none; }
    .research-market { font-size: 13px; color: #f59e0b; font-weight: 600; margin-bottom: 4px; }
    .research-text { font-size: 12px; color: #94a3b8; line-height: 1.5; }
    .research-odds { font-size: 12px; color: #22c55e; margin-top: 4px; }
    .research-source { font-size: 11px; color: #475569; margin-top: 2px; }
    .research-time { font-size: 11px; color: #334155; margin-top: 4px; }

    /* ── Пустые состояния ── */
    .empty { text-align: center; color: #475569; padding: 40px 20px; font-size: 13px; }

    /* Scrollbar */
    ::-webkit-scrollbar { width: 6px; }
    ::-webkit-scrollbar-track { background: transparent; }
    ::-webkit-scrollbar-thumb { background: #1e293b; border-radius: 3px; }
    ::-webkit-scrollbar-thumb:hover { background: #334155; }
  </style>
</head>
<body>

<div class="header">
  <span style="font-size: 22px;">&#x25C8;</span>
  <h1>NearCast Agents</h1>
  <span class="status" id="status"><span class="dot offline" id="statusDot"></span> connecting...</span>
</div>

<div class="container">
  <!-- Карточки агентов -->
  <div class="agents-grid" id="agentsGrid">
    <div class="empty">Waiting for agents...</div>
  </div>

  <!-- Два столбца: лента + research -->
  <div class="two-col">
    <div>
      <div class="section-title">Live Feed</div>
      <div class="events-panel" id="eventsPanel">
        <div class="empty">No events yet</div>
      </div>
    </div>
    <div>
      <div class="section-title">Shark Research</div>
      <div class="research-panel" id="researchPanel">
        <div class="empty">No research yet</div>
      </div>
    </div>
  </div>
</div>

<script>
  // ── State ──
  let lastEventId = 0;
  let allEvents = [];

  // ── Helpers ──
  function timeAgo(iso) {
    if (!iso) return "";
    const d = new Date(iso.includes("Z") ? iso : iso + "Z");
    const s = Math.floor((Date.now() - d.getTime()) / 1000);
    if (s < 60) return s + "s ago";
    if (s < 3600) return Math.floor(s / 60) + "m ago";
    if (s < 86400) return Math.floor(s / 3600) + "h ago";
    return Math.floor(s / 86400) + "d ago";
  }

  function shortAddr(a) {
    if (!a) return "";
    return a.length > 16 ? a.slice(0, 8) + "..." + a.slice(-4) : a;
  }

  function pnlClass(v) {
    if (v > 0) return "positive";
    if (v < 0) return "negative";
    return "zero";
  }

  function pnlStr(v) {
    if (v > 0) return "+" + v.toFixed(2);
    return v.toFixed(2);
  }

  // ── Render agents ──
  function renderAgents(agents) {
    const grid = document.getElementById("agentsGrid");
    if (!agents.length) {
      grid.innerHTML = '<div class="empty">Waiting for agents...</div>';
      return;
    }

    grid.innerHTML = agents.map(a => {
      const isOnline = a.last_active && (Date.now() - new Date(a.last_active + "Z").getTime()) < 30 * 60 * 1000;
      return `
        <div class="agent-card">
          <div class="top">
            <span class="avatar">${a.agent_avatar || "?"}</span>
            <div>
              <div class="name">${a.agent_name}</div>
              <div class="account">${shortAddr(a.account_id)}</div>
            </div>
          </div>
          <div class="pnl ${pnlClass(a.pnl_near)}">${pnlStr(a.pnl_near)} NEAR</div>
          <div class="stats">
            Bets: <span>${a.total_bets}</span> &nbsp; Won: <span>${a.won}</span> &nbsp; Lost: <span>${a.lost}</span><br>
            Win rate: <span>${(a.win_rate * 100).toFixed(0)}%</span> &nbsp; Balance: <span>${(a.balance_near || 0).toFixed(1)} NEAR</span><br>
            Cycles: <span>${a.cycle_count || 0}</span>
          </div>
          <div class="last-active">
            <span class="dot ${isOnline ? "online" : "offline"}"></span>
            ${a.last_active ? timeAgo(a.last_active) : "never"}
          </div>
        </div>`;
    }).join("");
  }

  // ── Render events ──
  function formatEvent(e) {
    let text = "";
    switch (e.event_type) {
      case "bet":
        text = `<span class="highlight">${e.amount_near} NEAR</span> on market #${e.market_id}`;
        if (e.message) text += ` — ${e.message.slice(0, 80)}`;
        break;
      case "chat":
      case "reply":
        text = `#${e.market_id}: "${(e.message || "").slice(0, 100)}"`;
        break;
      case "win":
        text = `<span class="highlight">+${(e.pnl_near || 0).toFixed(2)} NEAR</span> on market #${e.market_id}`;
        break;
      case "loss":
        text = `<span class="highlight">${(e.pnl_near || 0).toFixed(2)} NEAR</span> on market #${e.market_id}`;
        break;
      case "research":
        text = `#${e.market_id}: ${(e.message || "").slice(0, 120)}`;
        break;
      case "void":
        text = `Market #${e.market_id} voided`;
        break;
      default:
        text = e.message || e.event_type;
    }
    return text;
  }

  function renderEvents() {
    const panel = document.getElementById("eventsPanel");
    if (!allEvents.length) {
      panel.innerHTML = '<div class="empty">No events yet</div>';
      return;
    }

    panel.innerHTML = allEvents.slice(0, 100).map(e => `
      <div class="event-row">
        <span class="event-avatar">${e.agent_avatar || "?"}</span>
        <span class="event-badge ${e.event_type}">${e.event_type}</span>
        <span class="event-text">${formatEvent(e)}</span>
        <span class="event-time">${timeAgo(e.created_at)}</span>
      </div>
    `).join("");
  }

  // ── Render research ──
  function renderResearch(items) {
    const panel = document.getElementById("researchPanel");
    if (!items.length) {
      panel.innerHTML = '<div class="empty">No research yet</div>';
      return;
    }

    panel.innerHTML = items.map(r => {
      let odds = "";
      let sources = "";
      try {
        const meta = JSON.parse(r.metadata || "{}");
        if (meta.realOdds && meta.realOdds.probabilities) {
          odds = meta.realOdds.outcomes
            .map((o, i) => `${o}: ${(meta.realOdds.probabilities[i] * 100).toFixed(0)}%`)
            .join(" vs ");
        }
        if (meta.sources) sources = meta.sources;
      } catch {}

      return `
        <div class="research-item">
          <div class="research-market">Market #${r.market_id}</div>
          <div class="research-text">${(r.message || "").slice(0, 200)}</div>
          ${odds ? `<div class="research-odds">${odds}</div>` : ""}
          ${sources ? `<div class="research-source">${sources}</div>` : ""}
          <div class="research-time">${timeAgo(r.created_at)}</div>
        </div>`;
    }).join("");
  }

  // ── Polling ──
  async function fetchAll() {
    try {
      const [agentsRes, eventsRes, researchRes] = await Promise.all([
        fetch("/api/agents").then(r => r.json()),
        fetch(`/api/events?after=${lastEventId}&limit=50`).then(r => r.json()),
        fetch("/api/research?limit=15").then(r => r.json()),
      ]);

      // Agents
      renderAgents(Array.isArray(agentsRes) ? agentsRes : []);

      // Events — prepend new, newest first
      if (Array.isArray(eventsRes) && eventsRes.length > 0) {
        const existingIds = new Set(allEvents.map(e => e.id));
        const newEvents = eventsRes.filter(e => !existingIds.has(e.id));
        if (newEvents.length > 0) {
          allEvents = [...newEvents, ...allEvents].slice(0, 200);
          lastEventId = Math.max(lastEventId, ...newEvents.map(e => e.id));
        }
        renderEvents();
      }

      // Research
      renderResearch(Array.isArray(researchRes) ? researchRes : []);

      // Status
      document.getElementById("statusDot").className = "dot online";
      document.getElementById("status").innerHTML = '<span class="dot online" id="statusDot"></span> connected';
    } catch (err) {
      document.getElementById("statusDot").className = "dot offline";
      document.getElementById("status").innerHTML = '<span class="dot offline" id="statusDot"></span> disconnected';
    }
  }

  // Первая загрузка + polling каждые 10 секунд
  fetchAll();
  setInterval(fetchAll, 10000);
</script>

</body>
</html>
